<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Liquid Widget Hiding</title>
    <style>
        /* =========================================
           1. 基础环境设置
           ========================================= */
        :root {
            /* 质感参数 */
            --glass-bg: rgba(240, 240, 255, 0.25);
            --glass-border: rgba(255, 255, 255, 0.4);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            --glass-blur: blur(16px) saturate(160%);
            
            /* 尺寸变量 */
            --drop-size: 60px;
            --menu-width: 70px; 
            --menu-height: 260px; 
            --submenu-width: 78px;
            --submenu-height: 144px;
            --submenu-gap: 12px;
            
            /* 动画曲线 */
            --ease-elastic: cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        /* 背景层 */
        .bg-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-image: url("file:///D:/G/Katanegai/Extracted_Final/Images_CG_p/35d3d9bfcb4340b3c9d8d80fb7d4cd90.png");
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* =========================================
           2. 核心组件
           ========================================= */
        #drop-container {
            position: absolute;
            top: 0;
            left: 0;
            width: var(--drop-size);
            height: var(--drop-size);
            z-index: 100;
            /* 初始位置 */
            transform: translate3d(calc(100vw - 100px), 100px, 0); 
            touch-action: none;
            cursor: pointer;
            transition: opacity 0.6s ease;
        }

        /* 闲置半透明态（保留原有逻辑） */
        #drop-container.is-idle {
            opacity: 0.3; 
        }

        /* =========================================
           3. 水珠视觉层
           ========================================= */
        .drop-body {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transform-origin: center center;
            
            transition: 
                width 0.4s var(--ease-elastic),
                height 0.4s var(--ease-elastic),
                border-radius 0.4s ease,
                background-color 0.3s ease;
        }

        /* 高光 */
        .drop-body::after {
            content: '';
            position: absolute;
            top: 8%;
            left: 12%;
            width: 40%;
            height: 25%;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            opacity: 0.7;
            pointer-events: none;
            filter: blur(2px);
        }

        /* 呼吸动画 */
        @keyframes breath {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
        
        #drop-container:not(.is-dragging):not(.is-expanded) .drop-body {
            animation: breath 6s ease-in-out infinite;
        }

        /* =========================================
           4. 分层内容
           ========================================= */
        
        .icon-gear-wrapper {
            position: absolute;
            width: 24px;
            height: 24px;
            opacity: 0.6;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .icon-gear-wrapper svg {
            width: 100%;
            height: 100%;
            fill: #fff;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }

        #drop-container.is-expanded .icon-gear-wrapper {
            opacity: 0;
            transform: scale(0.5);
        }

        /* 菜单列表容器 */
        .menu-list {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column; /* 纵向 */
            align-items: center;
            justify-content: space-evenly;
            
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
            transition: opacity 0.2s 0.1s, transform 0.3s var(--ease-elastic) 0.1s;
        }

        #drop-container.is-expanded .menu-list {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        /* 展开时的尺寸调整 */
        #drop-container.is-expanded .drop-body {
            width: var(--menu-width);
            height: var(--menu-height);
            border-radius: 35px;
            background: rgba(240, 240, 255, 0.45);
            overflow: visible;
        }

        .menu-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            font-size: 0;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            position: relative;
        }

        .menu-item:hover {
            background: rgba(255,255,255,0.4);
        }
        .menu-item:active {
            transform: scale(0.9);
        }

        .menu-item.close-btn {
            background: rgba(0, 0, 0, 0.1);
        }
        .menu-item.close-btn svg {
            fill: rgba(0,0,0,0.6);
        }
        .menu-item svg {
            width: 20px;
            height: 20px;
            fill: rgba(255,255,255,0.9);
        }

        .submenu-panel {
            position: absolute;
            left: calc(100% + var(--submenu-gap));
            top: 58px;
            width: var(--submenu-width);
            height: var(--submenu-height);
            padding: 10px 8px;
            border-radius: 24px;
            background: rgba(240, 240, 255, 0.42);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transform: translateX(-10px) scale(0.95);
            transform-origin: left center;
            transition: opacity 0.2s ease, transform 0.25s var(--ease-elastic);
        }

        .submenu-panel.is-open {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(0) scale(1);
        }

        .submenu-item {
            width: 46px;
            height: 36px;
            border: 0;
            border-radius: 18px;
            background: rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.95);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
        }

        .submenu-item:hover {
            background: rgba(255,255,255,0.45);
        }

        .submenu-item:active {
            transform: scale(0.94);
        }

        /* Stagger 动画 */
        #drop-container.is-expanded .menu-item:nth-child(1) { transition-delay: 0.05s; }
        #drop-container.is-expanded .menu-item:nth-child(2) { transition-delay: 0.1s; }
        #drop-container.is-expanded .menu-item:nth-child(3) { transition-delay: 0.15s; }
        #drop-container.is-expanded .menu-item:nth-child(4) { transition-delay: 0.2s; }

    </style>
</head>
<body>

    <div class="bg-layer"></div>

    <div id="drop-container">
        <div class="drop-body" id="drop-visual">
            <div class="icon-gear-wrapper">
                <!-- 齿轮图标 -->
                <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
            </div>

            <div class="menu-list">
                <div class="menu-item close-btn" title="Close"><svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg></div>
                <div class="menu-item chat-btn" data-action="chat" title="Chat"><svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg></div>
                <div class="menu-item" data-action="record" title="Record"><svg viewBox="0 0 24 24"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg></div>
                <div class="menu-item" data-action="settings" title="Settings"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div>
            </div>
            <div class="submenu-panel" id="chat-submenu" aria-hidden="true">
                <button class="submenu-item" type="button">a</button>
                <button class="submenu-item" type="button">b</button>
                <button class="submenu-item" type="button">c</button>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('drop-container');
        const visual = document.getElementById('drop-visual');
        const menuItems = document.querySelectorAll('.menu-item');
        const closeButton = document.querySelector('.menu-item.close-btn');
        const chatButton = document.querySelector('.menu-item.chat-btn');
        const chatSubmenu = document.getElementById('chat-submenu');
        const submenuItems = document.querySelectorAll('.submenu-item');
        
        const EXPANDED_WIDTH = 70;
        const EXPANDED_HEIGHT = 260;
        const BASE_SIZE = 60;
        const SUBMENU_WIDTH = 78;
        const SUBMENU_HEIGHT = 144;
        const SUBMENU_GAP = 12;

        const state = {
            x: window.innerWidth - 100, 
            y: 100,                    
            vx: 0, 
            vy: 0, 
            isDragging: false,
            isExpanded: false,
            isIdle: false,
            isSubmenuOpen: false,
        };

        let dragOffset = { x: 0, y: 0 };
        let lastPos = { x: 0, y: 0 };
        // 新增：记录按下时的位置，用于判定是点击还是拖拽
        let startClickPos = { x: 0, y: 0 };
        let pointerId = null;
        let idleTimer = null;
        let targetSnap = null; 

        // 参数配置
        const IDLE_TIMEOUT = 3000;
        const FRICTION = 0.85;
        const SPRING = 0.1;
        const SNAP_THRESHOLD = 100;
        const STRETCH_FACTOR = 0.3;
        const MAX_STRETCH = 0.3;

        // 【新逻辑】吸附时的留白：这里控制“半隐藏”
        // 正常展开时留白 10px，未展开吸附时为负的一半宽度（即藏进去一半）
        const SCREEN_MARGIN_EXPANDED = 10;
        const HIDING_RATIO = 0.4; // 藏进去 60%，露出 40%

        function init() {
            container.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onResize);
            document.addEventListener('mousemove', resetIdleTimer);
            document.addEventListener('touchstart', resetIdleTimer);
            document.addEventListener('pointerdown', onDocumentPointerDown);
            
            // 点击事件
            container.addEventListener('click', onClickContainer);
            
            // 菜单点击
            closeButton.addEventListener('click', (e) => {
                e.stopPropagation(); 
                collapseMenu();
            });

            chatButton.addEventListener('click', (e) => {
                e.stopPropagation();
                triggerRipple(chatButton);
                toggleChatSubmenu();
            });

            menuItems.forEach((btn) => {
                const action = btn.dataset.action;
                if (!action || action === 'chat') return;

                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    triggerRipple(btn);
                    closeChatSubmenu();
                    console.log(`Action ${action} clicked`);
                });
            });

            submenuItems.forEach((btn) => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    triggerRipple(btn);
                    console.log(`Submenu ${btn.textContent.trim()} clicked`);
                });
            });

            requestAnimationFrame(animate);
            resetIdleTimer();
        }

        function onPointerDown(e) {
            if (e.target.closest('.menu-item, .submenu-item')) return;

            // 如果在隐藏状态被点中，先只唤醒，不开始拖拽逻辑，防止一点就飞了
            if (state.isIdle) {
                wakeUp();
                // 注意：这里不 return，因为可能是用户想直接拖拽
            }
            
            const rect = container.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            state.isDragging = true;
            container.classList.add('is-dragging');
            container.setPointerCapture(e.pointerId);
            pointerId = e.pointerId;

            state.vx = 0;
            state.vy = 0;
            lastPos.x = e.clientX;
            lastPos.y = e.clientY;

            // 记录初始点，用于区分 Click vs Drag
            startClickPos.x = e.clientX;
            startClickPos.y = e.clientY;
        }

        function onPointerMove(e) {
            resetIdleTimer();
            if (!state.isDragging) return;
            
            const targetX = e.clientX - dragOffset.x;
            const targetY = e.clientY - dragOffset.y;

            // 简单防抖动，只有真的移动时才计算速度
            state.vx = e.clientX - lastPos.x;
            state.vy = e.clientY - lastPos.y;
            
            state.x = targetX;
            state.y = targetY;

            lastPos.x = e.clientX;
            lastPos.y = e.clientY;
        }

        function onPointerUp(e) {
            if (!state.isDragging) return;
            state.isDragging = false;
            container.classList.remove('is-dragging');
            if (pointerId !== null && container.hasPointerCapture(pointerId)) {
                container.releasePointerCapture(pointerId);
            }
            pointerId = null;
            
            // 松手后立即计算吸附目标
            handleSnap();
        }

        // 核心修改逻辑：处理吸附和隐藏
        function handleSnap() {
            const currentW = state.isExpanded ? EXPANDED_WIDTH : BASE_SIZE;
            const currentH = state.isExpanded ? EXPANDED_HEIGHT : BASE_SIZE;
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;

            let destX = state.x;
            let destY = state.y;

            // 距离四边的距离
            const distLeft = state.x;
            const distRight = screenW - (state.x + currentW);
            const distTop = state.y;
            const distBottom = screenH - (state.y + currentH);

            // 定义吸附后的位置值
            // 如果已展开：必须在屏幕内 (SCREEN_MARGIN_EXPANDED = 10px)
            // 如果未展开：且距离小于阈值，则藏进墙里 (偏移量)
            let snapMarginX = SCREEN_MARGIN_EXPANDED;
            let snapMarginY = SCREEN_MARGIN_EXPANDED;

            if (!state.isExpanded) {
                // 计算需要藏进去的深度 (宽度的一半负值)
                const hideOffset = BASE_SIZE * HIDING_RATIO; // 比如 60 * 0.4 = 24px
                // 左侧吸附坐标：-24px
                // 右侧吸附坐标：ScreenW - 60 + 24px
                
                // === X轴判断 ===
                if (distLeft < SNAP_THRESHOLD) {
                    destX = -hideOffset; 
                } else if (distRight < SNAP_THRESHOLD) {
                    destX = screenW - currentW + hideOffset;
                } else {
                    // 屏幕中间，限制不出界
                    if (destX < SCREEN_MARGIN_EXPANDED) destX = SCREEN_MARGIN_EXPANDED;
                    if (destX > screenW - currentW - SCREEN_MARGIN_EXPANDED) destX = screenW - currentW - SCREEN_MARGIN_EXPANDED;
                }

                // === Y轴判断 === (如果你也想上下能藏进去，逻辑同上)
                // 这里我们让角落也能藏
                if (distTop < SNAP_THRESHOLD) {
                    destY = -hideOffset;
                } else if (distBottom < SNAP_THRESHOLD) {
                    destY = screenH - currentH + hideOffset;
                } else {
                    if (destY < SCREEN_MARGIN_EXPANDED) destY = SCREEN_MARGIN_EXPANDED;
                    if (destY > screenH - currentH - SCREEN_MARGIN_EXPANDED) destY = screenH - currentH - SCREEN_MARGIN_EXPANDED;
                }

            } else {
                // === 展开状态：严格限制在屏幕内 ===
                if (distLeft < SNAP_THRESHOLD) destX = SCREEN_MARGIN_EXPANDED;
                else if (distRight < SNAP_THRESHOLD) destX = screenW - currentW - SCREEN_MARGIN_EXPANDED;
                else {
                    if (destX < SCREEN_MARGIN_EXPANDED) destX = SCREEN_MARGIN_EXPANDED;
                    if (destX > screenW - currentW - SCREEN_MARGIN_EXPANDED) destX = screenW - currentW - SCREEN_MARGIN_EXPANDED;
                }
                
                // Y轴同理
                if (distTop < SNAP_THRESHOLD) destY = SCREEN_MARGIN_EXPANDED;
                else if (distBottom < SNAP_THRESHOLD) destY = screenH - currentH - SCREEN_MARGIN_EXPANDED;
                else {
                    if (destY < SCREEN_MARGIN_EXPANDED) destY = SCREEN_MARGIN_EXPANDED;
                    if (destY > screenH - currentH - SCREEN_MARGIN_EXPANDED) destY = screenH - currentH - SCREEN_MARGIN_EXPANDED;
                }
            }

            targetSnap = { x: destX, y: destY };
        }

        function onResize() {
            handleSnap();
            if (state.isExpanded && state.isSubmenuOpen) {
                ensureSubmenuVisible();
                positionSubmenuAtChat();
            }
        }

        function animate() {
            // 如果非拖拽状态，应用物理效果
            if (!state.isDragging) {
                if (targetSnap) {
                    // 弹簧吸附 logic
                    const dx = targetSnap.x - state.x;
                    const dy = targetSnap.y - state.y;
                    state.vx += dx * SPRING;
                    state.vy += dy * SPRING;
                    state.vx *= FRICTION;
                    state.vy *= FRICTION;

                    // 停止阈值
                    if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5 && Math.abs(state.vx) < 0.1 && Math.abs(state.vy) < 0.1) {
                        state.x = targetSnap.x;
                        state.y = targetSnap.y;
                        state.vx = 0;
                        state.vy = 0;
                        targetSnap = null;
                    }
                } else {
                    // 自由滑动 logic
                    state.vx *= FRICTION;
                    state.vy *= FRICTION;
                    
                    const rectW = state.isExpanded ? EXPANDED_WIDTH : BASE_SIZE;
                    const rectH = state.isExpanded ? EXPANDED_HEIGHT : BASE_SIZE;

                    // 碰撞反弹 (宽松一点，允许稍微出界因为handleSnap会修正)
                    if (state.x < -BASE_SIZE || state.x > window.innerWidth) state.vx *= -0.5;
                    if (state.y < -BASE_SIZE || state.y > window.innerHeight) state.vy *= -0.5;
                }
                state.x += state.vx;
                state.y += state.vy;
            }

            container.style.transform = `translate3d(${state.x}px, ${state.y}px, 0)`;

            // 形变逻辑
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            if (!state.isExpanded) {
                let scaleX = 1;
                let scaleY = 1;
                let angle = 0;
                if (velocity > 1) {
                    angle = Math.atan2(state.vy, state.vx);
                    const stretch = Math.min(velocity * STRETCH_FACTOR * 0.01, MAX_STRETCH);
                    scaleX = 1 + stretch;
                    scaleY = 1 - stretch * 0.5;
                }
                visual.style.transform = `rotate(${angle}rad) scale(${scaleX}, ${scaleY})`;
            } else {
                visual.style.transform = 'none';
            }

            requestAnimationFrame(animate);
        }

        function resetIdleTimer() {
            if (state.isExpanded) return;
            if (state.isIdle) wakeUp();
            clearTimeout(idleTimer);
            idleTimer = setTimeout(goIdle, IDLE_TIMEOUT);
        }

        function goIdle() {
            if (state.isDragging || state.isExpanded) return;
            state.isIdle = true;
            container.classList.add('is-idle');
        }

        function wakeUp() {
            state.isIdle = false;
            container.classList.remove('is-idle');
            visual.animate([
                { transform: 'scale(0.95)' },
                { transform: 'scale(1.05)' },
                { transform: 'scale(1)' }
            ], { duration: 400, easing: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)' });
            clearTimeout(idleTimer);
            idleTimer = setTimeout(goIdle, IDLE_TIMEOUT);
        }

        function onDocumentPointerDown(e) {
            if (!state.isExpanded) return;
            if (container.contains(e.target)) return;
            collapseMenu();
        }

        function onClickContainer(e) {
            if (state.isIdle) return; // 如果是idle状态，第一次点击当作唤醒，不展开

            // 【关键修改】判断是否不仅可以点击，还得是没有发生明显位移
            // 计算按下到松开的距离
            const dx = e.clientX - startClickPos.x;
            const dy = e.clientY - startClickPos.y;
            const distance = Math.sqrt(dx*dx + dy*dy);

            // 如果位移超过 5px，认为是拖拽操作，不触发展开
            if (distance > 5) {
                return;
            }

            if (!state.isExpanded) {
                expandMenu();
            }
        }

        function expandMenu() {
            closeChatSubmenu();
            // 展开前，先把位置吸附目标改成“屏幕内”
            // 这样如果它在墙里藏着，会先滑出来再展开，动画更自然
            let newX = state.x;
            let newY = state.y;
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            
            // 检查并修正位置，使其完全进入屏幕
            if(newX < 0) newX = SCREEN_MARGIN_EXPANDED;
            if(newX > screenW - EXPANDED_WIDTH - SCREEN_MARGIN_EXPANDED) {
                newX = screenW - EXPANDED_WIDTH - SCREEN_MARGIN_EXPANDED;
            }
            if(newY < 0) newY = SCREEN_MARGIN_EXPANDED;
            
            // 检查底部空间 (向下展开特有逻辑)
            if (screenH - newY < EXPANDED_HEIGHT + 20) {
                newY = screenH - EXPANDED_HEIGHT - 20;
            }

            // 设置吸附目标并在到达后触发展开动画
            targetSnap = { x: newX, y: newY };
            
            // 立即标记为展开态，这样 animate 循环里的边界碰撞检测就会改变
            state.isExpanded = true; 
            container.classList.add('is-expanded');
            clearTimeout(idleTimer);

            // 视觉上的跳动提示
            visual.animate([
                { transform: 'translateY(0) scale(1,1)' },
                { transform: 'translateY(-15px) scale(0.9, 1.1)' }, 
                { transform: 'translateY(0) scale(1,1)' }
            ], { duration: 300, easing: 'ease-out' });
        }

        function collapseMenu() {
            closeChatSubmenu();
            state.isExpanded = false;
            container.classList.remove('is-expanded');
            resetIdleTimer();
            // 收起后，触发一次吸附，让它自己判断要不要藏回墙里
            setTimeout(handleSnap, 400); 
        }

        function toggleChatSubmenu() {
            if (!state.isExpanded) return;
            if (state.isSubmenuOpen) {
                closeChatSubmenu();
            } else {
                openChatSubmenu();
            }
        }

        function openChatSubmenu() {
            ensureSubmenuVisible();
            positionSubmenuAtChat();
            state.isSubmenuOpen = true;
            chatSubmenu.classList.add('is-open');
            chatSubmenu.setAttribute('aria-hidden', 'false');
        }

        function closeChatSubmenu() {
            state.isSubmenuOpen = false;
            chatSubmenu.classList.remove('is-open');
            chatSubmenu.setAttribute('aria-hidden', 'true');
        }

        function ensureSubmenuVisible() {
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            const maxX = screenW - EXPANDED_WIDTH - SCREEN_MARGIN_EXPANDED;
            const maxY = screenH - EXPANDED_HEIGHT - SCREEN_MARGIN_EXPANDED;
            const originalX = state.x;
            const originalY = state.y;

            if (state.x < SCREEN_MARGIN_EXPANDED) state.x = SCREEN_MARGIN_EXPANDED;
            if (state.x > maxX) state.x = maxX;
            if (state.y < SCREEN_MARGIN_EXPANDED) state.y = SCREEN_MARGIN_EXPANDED;
            if (state.y > maxY) state.y = maxY;

            const rightEdge = state.x + EXPANDED_WIDTH + SUBMENU_GAP + SUBMENU_WIDTH + SCREEN_MARGIN_EXPANDED;
            if (rightEdge > screenW) {
                const overflow = rightEdge - screenW;
                state.x = Math.max(SCREEN_MARGIN_EXPANDED, state.x - overflow);
            }

            if (state.x !== originalX || state.y !== originalY) {
                targetSnap = { x: state.x, y: state.y };
            }
        }

        function positionSubmenuAtChat() {
            const chatRect = chatButton.getBoundingClientRect();
            const visualRect = visual.getBoundingClientRect();

            let top = chatRect.top - visualRect.top + chatRect.height * 0.5 - SUBMENU_HEIGHT * 0.5;
            const minTop = 8;
            const maxTop = EXPANDED_HEIGHT - SUBMENU_HEIGHT - 8;
            if (top < minTop) top = minTop;
            if (top > maxTop) top = maxTop;

            chatSubmenu.style.top = `${top}px`;
        }

        function triggerRipple(element) {
            element.animate([
                { transform: 'scale(0.9)' },
                { transform: 'scale(1)' }
            ], { duration: 200, easing: 'ease-out' });
        }

        init();
    </script>
</body>
</html>
